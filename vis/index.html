<!doctype html>

<script src="d3.v4.js"></script>
<script src="graphlib-dot.js"></script>
<script src="dagre-d3.js"></script>

<style>
  svg {
      border: 0px;
      overflow: hidden;
  }

  .node {
      white-space: nowrap;
  }

  .node rect,
  .node circle,
  .node ellipse {
      stroke: #ffffff;
      fill: #fff;
      stroke-width: 1.5px;
  }
  
  .edgePath path {
      stroke: #ffffff;
      stroke-width: 1.5px;
      fill: #ffffff;
      border: 0.5px;
      border-color: #999999;
  }

</style>

<style>
  body {
      font-family: Comic Mono, monospace;
      background: #000000;
  }
  
  h1 {
      font-size: 14pt;
      color: #ffffff;
  }
  
  label {
      margin-top: 1em;
      display: block;
  }
</style>

<body>
  
  <h1>This is the current MÃ©gra Session !!1</h1>
  
</body>

<script>
  
  // Create and configure the renderer (well, not much to configure so far)
  var render = dagreD3.render();

  var last = 0;
  var updateInterval = 100; // update roughly every 50 ms ... given that a typical time interval in megra is 100ms, this should be ok

  var svgDict = {};
  
  function draw(timestamp) {
      
      if((timestamp - last) > updateInterval) {
          // set timestamp
          last = timestamp;

          fetch("../all").then(function(plain_dot) {                          
              plain_dot.text().then(function(text_dot) {

                  // nothing else to do in that case
                  if(text_dot === "") {
                      Object.keys(svgDict).forEach(function(key) {                          
                          svgDict[key].remove();
                          delete svgDict[key];                          
                      });
                      return;
                  }
                  
                  try {
                      var procs = graphlibDot.readMany(text_dot);
                      var procnames = [];

                      procs.forEach(function(p, index, array) {
                          var procname = p._label.id;
                          procnames.push(procname);
                          
                          // inject into DOM
                          if(!svgDict.hasOwnProperty(procname)) {                                  
                              svgDict[procname] = d3.select("body")
                                  .append("svg")                                  
                                  .attr("id", procname);
                              svgDict[procname].append("g");                                                                                                      
                          }
                          
                          svgDict[procname].select("g").call(render, p);
                          svgDict[procname].attr("width", p.graph().width).attr("height", p.graph().height);
                      });

                      Object.keys(svgDict).forEach(function(key) {
                          if(!procnames.includes(key)) {
                              svgDict[key].remove();
                              delete svgDict[key];
                          }                    
                      });
                      
                  } catch (e) {
                      // sth sth error handling
                      console.log(e);
                      throw e;
                  }
              });
          });          
      }
      
      window.requestAnimationFrame(draw);            
  }

  // start animating
  window.requestAnimationFrame(draw);
  
</script>
