<!DOCTYPE html>

<head>
  <title>Mégra Visualizer</title>
  <meta charset="UTF-8" />        
  <script src="/node_modules/osc/dist/osc-browser.js"></script>
  <script src="/node_modules/d3/dist/d3.js"></script> 
</head>

<style>
  body {
      font-family: Comic Mono, monospace;
      background: #000;
      font-size: 6pt;
  }
  
  svg {
      border: 0px;
      overflow: hidden;
  }
  
  path.link {
      fill: none;
      stroke: #fff;
      stroke-width: 1.5px;
  }

  circle {      
      stroke: #fff;
      stroke-width: 1.5px;
  }

  text {
      fill: #000;
      font-size: 6pt;
      font-family: Comic Mono, monospace;
      pointer-events: none;
  }
  
  h1 {
      font-size: 12pt;
      color: #ffffff;
  }
  
</style>

<body>

  <h1>Current Mégra Session !</h1>
  
</body>

<script>
  
  // keep graphs and svgs here ...
  var graph_sources = {};
  var graphs = {};
  var layouts = {};
  var restarts = {};
  var graph_svgs = {};    
  var last_active = {};
  
  function linkArc(d) {
      // Self edge.
      var x1 = d.source.x;
      var x2 = d.target.x;
      var y1 = d.source.y;
      var y2 = d.target.y;
      if ( x1 === x2 && y1 === y2 ) {
          // Fiddle with this angle to get loop oriented.
          xRotation = -80;

          // Needs to be 1.
          largeArc = 1;

          // Change sweep to change orientation of loop. 
          sweep = 0;

          // Make drx and dry different to get an ellipse
          // instead of a circle.
          drx = 17;
          dry = 12;

          // For whatever reason the arc collapses to a point if the beginning
          // and ending points of the arc are the same, so kludge it.
          x2 = x2 + 1;
          y2 = y2 + 1;
	  return "M" + x1 + "," + y1 + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
      } else {
	  const r = Math.hypot(d.target.x - d.source.x, d.target.y - d.source.y);
	  return `M${d.source.x},${d.source.y} A${r},${r} 0 0,1 ${d.target.x},${d.target.y}`;
      }      
  }

  // calculate edge thickness from probablity
  function thickness(prob) {
      return 0.2 + (3.0 * (prob / 100.0));
  }
  
  function renderSingle(name) {      
      var width = 500;
      var height = 500;

      var init_nodes = Object.values(graphs[name].nodes);
      var init_links = Object.values(graphs[name].links);

      var force = d3.forceSimulation(init_nodes)
	  .force("charge", d3.forceManyBody().strength(-1300))
	  .force("link", d3.forceLink(init_links).id(d => d.id))	  
	  .force("center", d3.forceCenter(width / 2, height / 2))
	  .force("x", d3.forceX())
	  .force("y", d3.forceY());
      
      var svg = d3.select("body").append("svg")
	  .attr("width", width)
	  .attr("height", height);
      
      // end markers (the little arrows)
      svg.append("defs").selectAll("marker")
	  .data(["regular"])
	  .join("marker")
	  .attr("id", "arrow-regular")
	  .attr("markerUnits", "userSpaceOnUse") // this let's us define marker dimensions independent from the parent path
	  .attr("viewBox", "0 -5 10 10")
	  .attr("refX", 16)
	  .attr("refY", -0.5)
	  .attr("markerWidth", 12)
	  .attr("markerHeight", 12)
	  .attr("orient", "auto")
	  .append("path")
	  .attr("fill", "#fff")
	  .attr("d", "M0,-5L10,0L0,5");

      var nodeGroup = svg.append("g");
      var linkGroup = svg.append("g")
	  .attr("fill", "none");
      
      var node;
      var link;
      
      restarts[name] = function () {

	  var nodes = Object.values(graphs[name].nodes);
	  var links = Object.values(graphs[name].links);
	  	  	  
	  // nodes
	  node = nodeGroup
	      .attr("stroke-linecap", "round")
	      .attr("stroke-linejoin", "round")
	      .selectAll("g")
	      .data(nodes)
	      .join("g")

	  node.append("circle")
	      .attr("id", d => name + "-" + d.id)
	      .attr("stroke", "white")
	      .attr("stroke-width", 1.5)
	      .attr("r", 9)
	      .attr("fill", "#afa");

	  // node text
	  node.append("text")
	      .attr("x", -3)
	      .attr("y", 2)
	      .text(d => d.label)
	      .clone(true).lower()
	      .attr("fill", "none")
	      .attr("stroke", "#afa")
	      .attr("stroke-width", 3);

	  // edges
	  link = linkGroup
	      .selectAll("path")
	      .data(links)
	      .join("path")
	      .attr("id", d => name + `-${d.source.id}-${d.target.id}`)
	      .attr("stroke", "#fff")	  
	      .attr("stroke-width", d => thickness(d.prob))
	      .attr("marker-end", d => d.source == d.target ? '' : `url(${new URL(`#arrow-${d.type}`, location)})`);

	  // edge labels
	  linkGroup.selectAll("text")
	      .data(links)	  
	      .join("text")	  
              .append("textPath")
      	      .attr("startOffset", "39%")
	      .attr('xlink:href', d => `#${name}-${d.source.id}-${d.target.id}`)
	      .text(d => d.label)
	      .clone(true).lower()
	      .attr("fill", "none")
	      .attr("stroke", "#fdd")
	      .attr("stroke-width", 3);
	  
	  // Update and restart the simulation.
	  force.nodes(nodes);
	  force.force("link").links(links);
	  force.alpha(0.8).restart();	  
      }

      force.on("tick", () => {
	  link.attr("d", linkArc);
	  node.attr("transform", d => `translate(${d.x},${d.y})`);
      });
            
      // keep for easy remval ...
      graph_svgs[name] = svg;
      layouts[name] = force;

      // initial restart ...
      restarts[name]();
  }

  function updateGraph(name) {
      var created = false;

      if(!graphs.hasOwnProperty(name)) {
	  graphs[name] = {};
	  graphs[name].nodes = {};
	  graphs[name].links = {};
	  created = true;
      }

      // first, check for removed nodes
      Object.keys(graphs[name].nodes).forEach(function (key) {
	  if(!graph_sources[name].nodes.hasOwnProperty(key)){
	      delete graphs[name].nodes[key];
	  }
      });

      //and for removed edged 
      Object.keys(graphs[name].links).forEach(function (key) {
	  if(!graph_sources[name].links.hasOwnProperty(key)){
	      delete graphs[name].links[key];
	  }
      });

      // then, add or updated nodes ...
      Object.keys(graph_sources[name].nodes).forEach(function (key) {
	  if(graphs[name].nodes.hasOwnProperty(key)) {
	      graphs[name].nodes[key].id = graph_sources[name].nodes[key].id;
	      graphs[name].nodes[key].label = graph_sources[name].nodes[key].label;
	  } else {
	      graphs[name].nodes[key] = {
		  id: graph_sources[name].nodes[key].id,
		  label: graph_sources[name].nodes[key].label
	      };
	  }
      });

      // and edges ..
      Object.keys(graph_sources[name].links).forEach(function (key) {
	  if(graphs[name].links.hasOwnProperty(key)) {
	      graphs[name].links[key].prob = graph_sources[name].links[key].prob;
	      graphs[name].links[key].label = graph_sources[name].links[key].label;	     
	  } else {
	      graphs[name].links[key] = {
		  source: graph_sources[name].links[key].source,
		  target: graph_sources[name].links[key].target,
		  type: graph_sources[name].links[key].type,
		  prob: graph_sources[name].links[key].prob,
		  label: graph_sources[name].links[key].label
	      };
	  }		  
      });
      
      return created;
  }
  
  var oscPort = new osc.WebSocketPort({
      url: "ws://localhost:8081", // URL to your Web Socket server.
      metadata: true
  });
  
  oscPort.open();

  oscPort.on("message", function (msg) {

      switch(msg.address) {
      case "/graph/add": {
	  var name = msg.args[0].value;
	  
	  // always gets renewed
	  graph_sources[name] = {};
	  graph_sources[name].nodes = {};
	  graph_sources[name].links = {};	      
	  
	  break;
      }
      case "/node/add": {
	  var name = msg.args[0].value;
	  var node_id = msg.args[1].value;
	  var node_label = msg.args[2].value.trim();
	  
	  graph_sources[name].nodes[node_id] = {id: node_id, label: node_label};
	  
	  break;
      }
      case "/node/active": {
	  var name = msg.args[0].value;	  	  

	  if(graphs.hasOwnProperty(name)) {
	      var src = msg.args[1].value;

	      d3.select(`#${name}-${last_active[name]}`).attr("fill", "#afa");
	      d3.select(`#${name}-${src}`).attr("fill", "#f77");
	      
	      last_active[name] = src;
	  }
	  break;
      }
      case "/edge/add": {
	  var name = msg.args[0].value;
	  var src = msg.args[1].value;
	  var dest = msg.args[2].value;
	  var label = msg.args[3].value;
	  var prob = msg.args[4].value;
	  
	  if(graph_sources.hasOwnProperty(name)) {
	      var key = "" + src + "->" + dest;

	      graph_sources[name].links[key] = {
		  source: src,
		  target: dest,
		  type: "regular",
		  prob: prob,
		  label: label
	      };	      	      
	  }
	  
	  break;
      }
      case "/render": {
	  var name = msg.args[0].value;	  
	  
	  if(updateGraph(name)) { 	      
	      renderSingle(name);
	  } else {	      	      
	      restarts[name]();
	  }
	  
	  break;
      }
      case "/clear": {	  	  
	  var name = msg.args[0].value;
	  if(graph_sources.hasOwnProperty(name)) {	      
	      delete graph_sources[name];
	  }

	  if(graphs.hasOwnProperty(name)) {	      
	      delete graphs[name];
	  }
	  
	  if(layouts.hasOwnProperty(name)) {	      
	      delete layouts[name];
	  }
	  
	  if(graph_svgs.hasOwnProperty(name)) {
	      graph_svgs[name].remove();
	      delete graph_svgs[name];
	  }	  	  	  	  
	  break;
      }
      }            
  });
  
</script>
