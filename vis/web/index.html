<!DOCTYPE html>

<head>
  <title>Mégra Visualizer</title>
  <meta charset="UTF-8" />        
  <script src="/node_modules/osc/dist/osc-browser.js"></script>
  <script src="/node_modules/d3/dist/d3.js"></script> 
</head>

<style>
  body {
      font-family: Comic Mono, monospace;
      background: #000;
      font-size: 6pt;
  }
  
  svg {
      border: 0px;
      overflow: hidden;
  }
  
  path.link {
      fill: none;
      stroke: #fff;
      stroke-width: 1.5px;
  }

  circle {
      //fill: #afa;
      stroke: #fff;
      stroke-width: 1.5px;
  }

  text {
      fill: #000;
      font-size: 6pt;
      font-family: Comic Mono, monospace;
      pointer-events: none;
  }

  h1 {
      font-size: 12pt;
      color: #ffffff;
  }
  
</style>

<body>

  <h1>Current Mégra Session !</h1>
  
</body>

<script>
  
  // keep graphs and svgs here ...
  var graphs = {};
  var layouts = {};
  var graph_svgs = {};

  var last_active = {};

  function fixna(x) {
      if (isFinite(x)) return x;
      return 0;
  }

  function linkArc(d) {
      // Self edge.
      var x1 = d.source.x;
      var x2 = d.target.x;
      var y1 = d.source.y;
      var y2 = d.target.y;
      if ( x1 === x2 && y1 === y2 ) {
          // Fiddle with this angle to get loop oriented.
          xRotation = -80;

          // Needs to be 1.
          largeArc = 1;

          // Change sweep to change orientation of loop. 
          sweep = 0;

          // Make drx and dry different to get an ellipse
          // instead of a circle.
          drx = 17;
          dry = 12;

          // For whatever reason the arc collapses to a point if the beginning
          // and ending points of the arc are the same, so kludge it.
          x2 = x2 + 1;
          y2 = y2 + 1;
	  return "M" + x1 + "," + y1 + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
      } else {
	  const r = Math.hypot(d.target.x - d.source.x, d.target.y - d.source.y);
	  return `M${d.source.x},${d.source.y} A${r},${r} 0 0,1 ${d.target.x},${d.target.y}`;
      }      
  }

  // calculate edge thickness from probablity
  function thickness(prob) {
      return 0.2 + (3.0 * (prob / 100.0));
  }
  
  drag = simulation => {
      
      function dragstarted(d) {
	  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
	  d.fx = d.x;
	  d.fy = d.y;
      }
      
      function dragged(d) {
	  d.fx = d3.event.x;
	  d.fy = d3.event.y;
      }
      
      function dragended(d) {
	  if (!d3.event.active) simulation.alphaTarget(0);
	  d.fx = null;
	  d.fy = null;
      }
      
      return d3.drag()
	  .on("start", dragstarted)
	  .on("drag", dragged)
	  .on("end", dragended);
  }
  
  function renderSingle(name) {      
      var width = 500;
      var height = 500;

      var force = d3.forceSimulation(graphs[name].nodes)
	  .force("link", d3.forceLink(graphs[name].links).id(d => d.id))
	  .force("charge", d3.forceManyBody().strength(-1300))
	  .force("center", d3.forceCenter(width / 2, height / 2))
	  .force("x", d3.forceX())
	  .force("y", d3.forceY());
      
      var svg = d3.select("body").append("svg")
	  .attr("width", width)
	  .attr("height", height);
      
      // end markers (the little arrows)
      svg.append("defs").selectAll("marker")
	  .data(["regular"])
	  .join("marker")
	  .attr("id", "arrow-regular")
	  .attr("markerUnits", "userSpaceOnUse") // this let's us define marker dimensions independent from the parent path
	  .attr("viewBox", "0 -5 10 10")
	  .attr("refX", 16)
	  .attr("refY", -0.5)
	  .attr("markerWidth", 12)
	  .attr("markerHeight", 12)
	  .attr("orient", "auto")
	  .append("path")
	  .attr("fill", "#fff")
	  .attr("d", "M0,-5L10,0L0,5");

      // edges
      var link = svg.append("g")
	  .attr("fill", "none")	  
	  .selectAll("path")
	  .data(graphs[name].links)
	  .join("path")
	  .attr("id", d => name + `-${d.source.id}-${d.target.id}`)
	  .attr("stroke", "#fff")	  
	  .attr("stroke-width", d => thickness(d.prob))
	  .attr("marker-end", d => d.source == d.target ? '' : `url(${new URL(`#arrow-${d.type}`, location)})`);

      // edge labels
      svg.selectAll("text")
	  .data(graphs[name].links)	  
	  .join("text")	  
          .append("textPath")
      	  .attr("startOffset", "39%")
	  .attr('xlink:href', d => `#${name}-${d.source.id}-${d.target.id}`)
	  .text(d => `${d.label}`)
	  .clone(true).lower()
	  .attr("fill", "none")
	  .attr("stroke", "#fdd")
	  .attr("stroke-width", 3);

      // nodes
      var node = svg.append("g")
	  .attr("stroke-linecap", "round")
	  .attr("stroke-linejoin", "round")
	  .selectAll("g")
	  .data(graphs[name].nodes)
	  .join("g")	  
	  .call(drag(force));

      // node circles
      node.append("circle")
	  .attr("id", d => name + "-" + d.id)
	  .attr("stroke", "white")
	  .attr("stroke-width", 1.5)
	  .attr("r", 9)
	  .attr("fill", "#afa");

      // node text
      node.append("text")
	  .attr("x", -3)
	  .attr("y", 2)
	  .text(d => d.label)
	  .clone(true).lower()
	  .attr("fill", "none")
	  .attr("stroke", "#afa")
	  .attr("stroke-width", 3);

      force.on("tick", () => {
	  link.attr("d", linkArc);
	  node.attr("transform", d => `translate(${d.x},${d.y})`);
      });
      
      graph_svgs[name] = svg;
      layouts[name] = force;
  }
  
  var oscPort = new osc.WebSocketPort({
      url: "ws://localhost:8081", // URL to your Web Socket server.
      metadata: true
  });
  
  oscPort.open();

  oscPort.on("message", function (msg) {

      switch(msg.address) {
      case "/graph/add": {
	  var name = msg.args[0].value;
	  
	  console.log("add graph: " + name);

	  graphs[name] = {};
	  
	  graphs[name].nodes = [];
	  graphs[name].links = [];
	  
	  break;
      }
      case "/node/add": {
	  var graph_name = msg.args[0].value;
	  var node_id = msg.args[1].value;
	  var node_label = msg.args[2].value.trim();

	  console.log("add node with id " + node_id + " and label " + node_label + " to graph: " + graph_name);
	  
	  graphs[graph_name]['nodes'].push({id: node_id, label: node_label})
	  
	  break;
      }
      case "/node/active": {
	  var name = msg.args[0].value;	  	  

	  if(graphs.hasOwnProperty(name)) {
	      var src = msg.args[1].value;

	      d3.select(`#${name}-${last_active[name]}`).attr("fill", "#afa");
	      d3.select(`#${name}-${src}`).attr("fill", "#f77");

	      //console.log("set act" + `#${name}-${src}`);

	      last_active[name] = src;
	  }
	  break;
      }
      case "/edge/add": {
	  var name = msg.args[0].value;
	  var src = msg.args[1].value;
	  var dest = msg.args[2].value;
	  var label = msg.args[3].value;
	  var prob = msg.args[4].value;
	  
	  console.log("add edge " + src + " -> " + dest + " to graph " + name + " label " + label + " prob " + prob );

	  if(graphs.hasOwnProperty(name)) {
	      graphs[name].links.push ({
		  source: src,
		  target: dest,
		  type: "regular",
		  prob: prob,
		  label: label
	      });	      
	  }
	  
	  break;
      }
      case "/render": {
	  var name = msg.args[0].value;

	  if(graphs.hasOwnProperty(name) && !graph_svgs.hasOwnProperty(name)) {
	      renderSingle(name);
	  }
	  
	  break;
      }
      case "/clear": {	  	  
	  var name = msg.args[0].value;

	  if(layouts.hasOwnProperty(name)) {	      
	      delete layouts[name];
	  }
	  
	  if(graph_svgs.hasOwnProperty(name)) {
	      graph_svgs[name].remove();
	      delete graph_svgs[name];
	  }
	  if(graphs.hasOwnProperty(name)) {	      
	      delete graphs[name];
	  }
	  
	  break;
      }
      }            
  });
  
</script>
